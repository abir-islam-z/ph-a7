# বোনাস বিভাগ (যেকোনো ১০টি প্রশ্নের উত্তর দিন)

### 1. What is PostgreSQL?

PostgreSQL একটি শক্তিশালী ওপেন-সোর্স রিলেশনাল ডেটাবেইস। এটি রিলেশনাল এসকিউএল এবং নন-রিলেশনাল জেসন ডেটা ও কুয়েরি ব্যবহারের সুযোগ দেয়। PostgreSQL-এর পেছনে একটি শক্তিশালী কমিউনিটি রয়েছে। PostgreSQL একটি খুবই নির্ভরযোগ্য ডেটাবেইস ম্যানেজমেন্ট সিস্টেম, যেটিতে রয়েছে চমৎকার সাপোর্ট, সিকিউরিটি এবং একিউরেসি। অনেক মোবাইল এবং ওয়েব অ্যাপ্লিকেশন PostgreSQL-কে তাদের ডিফল্ট ডেটাবেইস হিসেবে ব্যবহার করে। অনেক জিওস্পেশিয়াল এবং অ্যানালিটিকস সল্যুশনেও PostgreSQL ব্যবহার করা হয়ে থাকে।

### 2. What is the purpose of a database schema in PostgreSQL?

PostgreSQL-এ স্কিমা হলো ডেটাবেইসের ভিতরে একটি গুচ্ছ বা ফোল্ডার টাইপ কাঠামো, যেখানে টেবিল, ভিউ, ফাংশন, সিকোয়েন্স ইত্যাদি অবজেক্ট গুছিয়ে রাখা যায়। এটি মূলত ডেটাবেইসকে সংগঠিত, নিরাপদ এবং সহজে ব্যবস্থাপনাযোগ্য রাখার জন্য ব্যবহৃত হয়। স্কিমা ব্যবহারের মাধ্যমে একই ডেটাবেইসের ভিতরে আলাদা আলাদা পরিবেশ বা মডিউল তৈরি করা যায়, যেমন `dev.users` এবং `prod.users`—যেখানে একই নামে টেবিল থাকা সত্ত্বেও কোনো সংঘর্ষ হয় না, কারণ তারা আলাদা স্কিমায় থাকে।

এছাড়া স্কিমাভিত্তিক পারমিশন কন্ট্রোলও দেওয়া যায়, অর্থাৎ নির্দিষ্ট স্কিমা শুধুমাত্র নির্দিষ্ট ইউজার বা রোল ব্যবহার করতে পারবে। PostgreSQL-এ ডিফল্টভাবে `public` নামে একটি স্কিমা থাকে, যেখানে সব টেবিল, ভিউ ইত্যাদি রাখা হয়, যদি না তুমি আলাদাভাবে কোনো স্কিমা উল্লেখ করো। স্কিমা ব্যবহারের মাধ্যমে ডেটাবেইস অ্যাপ্লিকেশন আরও স্কেলেবল, মডুলার এবং মেইনটেইনেবল হয়ে ওঠে।

### 3. Explain the **Primary Key** and **Foreign Key** concepts in PostgreSQL.

PostgreSQL-এ Primary Key এবং Foreign Key হলো রিলেশনাল ডেটাবেইসের সবচেয়ে গুরুত্বপূর্ণ দুটি কনসেপ্ট, যেগুলা টেবিলের মধ্যে ডেটার ইউনিকনেস আর রিলেশন বজায় রাখতে সাহায্য করে।

Primary Key এমন একটা কলাম (বা একাধিক কলাম), যেটা প্রতিটি রোকে ইউনিকভাবে আইডেন্টিফাই করে। অর্থাৎ, যেই কলামটাকে Primary Key হিসেবে ডিফাইন করা হয়, সেখানে ডুপ্লিকেট ভ্যালু বা null ভ্যালু রাখা যায় না। প্রতিটি টেবিলে সাধারণত একটি মাত্র Primary Key থাকে।

Foreign Key হলো এমন একটি কলাম, যেটা অন্য একটি টেবিলের Primary Key বা Unique Key-এর সাথে সম্পর্ক তৈরি করে। এর মাধ্যমে দুইটি টেবিলের মধ্যে লজিক্যাল সম্পর্ক স্থাপন করা যায়। উদাহরণস্বরূপ, যদি `orders` টেবিলে একটি `user_id` কলাম থাকে, এবং সেটি `users` টেবিলের `id` কলামের সাথে রিলেটেড হয়, তাহলে `orders.user_id` হবে একটি Foreign Key।

এই দুইটি কী একসাথে ডেটার ইন্টিগ্রিটি নিশ্চিত করে এবং ডেটাবেইসে কনসিস্টেন্সি বজায় রাখতে সাহায্য করে।

### 4. What is the difference between the `VARCHAR` and `CHAR` data types?

PostgreSQL-এ `VARCHAR` এবং `CHAR` উভয়ই টেক্সট-ভিত্তিক ডেটা টাইপ, যেগুলো স্ট্রিং বা শব্দ সংরক্ষণ করতে ব্যবহৃত হয়। তবে, এদের মধ্যে গুরুত্বপূর্ণ কিছু পার্থক্য রয়েছে।

`CHAR(n)` হচ্ছে Fixed-length টাইপ, যার মানে হলো তুমি যদি `CHAR(10)` ব্যবহার করো এবং সেখানে "hello" দাও, তাহলে বাকি ৫টা জায়গা ফাঁকা স্পেস দিয়ে ভরিয়ে দেওয়া হবে। এটা স্টোরেজে অতিরিক্ত জায়গা নেয়, এবং কিছু ক্ষেত্রে পারফরম্যান্সে প্রভাব ফেলতে পারে। সাধারণত তখনই ব্যবহার করা হয়, যখন প্রতিটি ভ্যালু ঠিক একই দৈর্ঘ্যের হবে বলে নিশ্চয়তা থাকে, যেমন: পিন কোড, স্টেট কোড ইত্যাদি।

অন্যদিকে, `VARCHAR(n)` হলো Variable-length টাইপ, যেটা শুধুমাত্র ইনপুট ডেটার দৈর্ঘ্য অনুযায়ী জায়গা নেয়। উদাহরণস্বরূপ, যদি `VARCHAR(10)` এ "hello" রাখা হয়, তাহলে শুধু ৫ অক্ষরের জায়গা নিবে, অতিরিক্ত কোনো স্পেস লাগবে না। এটা অনেক বেশি ফ্লেক্সিবল এবং সাধারণত বাস্তব জীবনের অ্যাপ্লিকেশনে বেশি ব্যবহৃত হয়।

সংক্ষেপে বললে, `CHAR` ফিক্সড-সাইজ আর `VARCHAR` ফ্লেক্সিবল—তাই প্রয়োজন অনুযায়ী বেছে নেওয়াই বুদ্ধিমানের কাজ।

### 5. Explain the purpose of the `WHERE` clause in a `SELECT` statement.

PostgreSQL-এ `SELECT` স্টেটমেন্টের মধ্যে `WHERE` ক্লজ ব্যবহার করা হয় নির্দিষ্ট শর্ত অনুযায়ী ডেটা ফিল্টার করার জন্য। যখন তুমি কোনো টেবিল থেকে সব ডেটা না নিয়ে, শুধুমাত্র কিছু নির্দিষ্ট রো (row) নিতে চাও যেগুলো কোনো কন্ডিশন বা শর্ত পূরণ করে, তখনই `WHERE` ক্লজ ব্যবহার করা হয়।

উদাহরণস্বরূপ, যদি তোমার `users` টেবিল থাকে এবং তুমি শুধু সেইসব ইউজারের নাম দেখতে চাও যাদের বয়স ১৮ বছরের বেশি, তাহলে তুমি লিখবে:  
`SELECT name FROM users WHERE age > 18;`

এখানে `WHERE age > 18` এই অংশটাই শর্ত, যা বলে দিচ্ছে শুধুমাত্র সেইসব রো রিটার্ন করো যেগুলোর বয়স ১৮-এর বেশি। `WHERE` ক্লজ ছাড়া `SELECT` সব রো রিটার্ন করে দেবে।

সোজা কথায়, `WHERE` হলো তোমার ডেটার উপর লেন্স – যেটা দিয়ে তুমি শুধুমাত্র দরকারি অংশটাই দেখো।

### 6. What are the `LIMIT` and `OFFSET` clauses used for?

**LIMIT:** এই ক্লজটি একটি কুয়েরি থেকে রিটার্ন করা রেকর্ডের সংখ্যা সীমিত করতে ব্যবহৃত হয়। উদাহরণস্বরূপ, `SELECT * FROM products LIMIT 10;` শুধুমাত্র প্রথম ১০টি প্রোডাক্ট রিটার্ন করবে।

**OFFSET:** এই ক্লজটি কুয়েরি শুরু করার আগে কতগুলি রেকর্ড স্কিপ করতে হবে তা নির্দিষ্ট করে। এটি প্রায়শই LIMIT-এর সাথে ব্যবহৃত হয় পেজিনেশন তৈরি করতে। উদাহরণস্বরূপ, `SELECT * FROM products LIMIT 10 OFFSET 20;` ২১ থেকে ৩০ পর্যন্ত প্রোডাক্ট (প্রথম ২০টি স্কিপ করে) রিটার্ন করবে।

### 7. How can you modify data using `UPDATE` statements?

UPDATE স্টেটমেন্ট ব্যবহার করে একটি টেবিলে বিদ্যমান রেকর্ডগুলির মান পরিবর্তন করতে যায়। UPDATE স্টেটমেন্টের বেসিক সিনট্যাক্স হল:

```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

WHERE ক্লজ নির্দিষ্ট করে কোন রেকর্ডগুলি আপডেট করা হবে। যদি WHERE ক্লজ না থাকে, টেবিলের সমস্ত রেকর্ড আপডেট হবে।

### 8. What is the significance of the `JOIN` operation, and how does it work in PostgreSQL?

JOIN অপারেশন PostgreSQL-এ একাধিক টেবিল থেকে ডাটা একত্রিত করার জন্য ব্যবহৃত হয়। এটি রিলেশনাল ডাটাবেসের একটি মূল বৈশিষ্ট্য, যা একটি কমন কলামের উপর ভিত্তি করে বিভিন্ন টেবিল থেকে ডাটা একত্রিত করতে দেয়।

PostgreSQL-এ বিভিন্ন ধরনের JOIN রয়েছে:

- **INNER JOIN:** দুটি টেবিলের মিল আছে এমন রেকর্ডগুলি রিটার্ন করে।
- **LEFT JOIN (বা LEFT OUTER JOIN):** বাম টেবিলের সব রেকর্ড এবং ডান টেবিলের মিল আছে এমন রেকর্ড রিটার্ন করে।
- **RIGHT JOIN (বা RIGHT OUTER JOIN):** ডান টেবিলের সব রেকর্ড এবং বাম টেবিলের মিল আছে এমন রেকর্ড রিটার্ন করে।
- **FULL JOIN (বা FULL OUTER JOIN):** যখন উভয় টেবিলে মিল আছে বা যেকোনো একটি টেবিলে রেকর্ড আছে তখন সব রেকর্ড রিটার্ন করে।

---- Done till here ----

### 9. Explain the `GROUP BY` clause and its role in aggregation operations.

GROUP BY ক্লজ কুয়েরি ফলাফলকে নির্দিষ্ট কলাম বা কলামগুলির ইউনিক ভ্যালুর উপর ভিত্তি করে গ্রুপ করতে ব্যবহৃত হয়। এটি সাধারণত এগ্রিগেট ফাংশনের সাথে ব্যবহৃত হয় (যেমন COUNT, SUM, AVG) প্রতিটি গ্রুপের উপর গণনা করতে।

উদাহরণস্বরূপ, `SELECT department, COUNT(*) FROM employees GROUP BY department;` প্রতিটি ডিপার্টমেন্টের কর্মচারীর সংখ্যা গণনা করবে। GROUP BY ছাড়া, COUNT() সমস্ত এমপ্লয়িদের গণনা করবে, কিন্তু GROUP BY সহ, এটি প্রতিটি পৃথক বা ইউনিক ডিপার্টমেন্টের জন্য পৃথক গণনা করে।

### 10. How can you calculate aggregate functions like `COUNT()`, `SUM()`, and `AVG()` in PostgreSQL?

PostgreSQL-এ এগ্রিগেট ফাংশন ব্যবহার করা সহজ এবং সাধারণত GROUP BY ক্লজের সাথে ব্যবহৃত হয়:

**COUNT():** কোনো কলামে রেকর্ডের সংখ্যা গণনা করে।

```sql
SELECT department, COUNT(*) FROM employees GROUP BY department;
```

**SUM():** একটি কলামের সকল মানের যোগফল গণনা করে।

```sql
SELECT department, SUM(salary) FROM employees GROUP BY department;
```

**AVG():** একটি কলামের মানগুলির গড় গণনা করে।

```sql
SELECT department, AVG(age) FROM employees GROUP BY department;
```

এই এগ্রিগেট ফাংশনগুলি HAVING ক্লজের সাথেও ব্যবহার করা যেতে পারে, যা GROUP BY দ্বারা সৃষ্ট গ্রুপগুলিকে ফিল্টার করার জন্য ব্যবহৃত হয়। উদাহরণস্বরূপ:

```sql
SELECT department, AVG(salary) FROM employees GROUP BY department HAVING AVG(salary) > 50000;
```
